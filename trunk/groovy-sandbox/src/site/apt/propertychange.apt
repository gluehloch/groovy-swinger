PropertyChangeEvent, PropertyChangeListener

  Meine Swing Projekte, die mit JGoodies-Binding ausgestattet sind, machen
  intensiven Gebrauch von dieser Java-Bean Technik. In diesem Zusammenhang
  ist es besonders ärgerlich, Java Klassen zu schreiben, die nach folgendem
  Muster implementiert sind:

+------------------------------------------------------------------------------+
public Person {

	private final PropertyChangeSupport pcs = new PropertyChangeSupport();

	public void addPropertyChangeListener(PropertyChangeListener listener) {
		pcs.addPropertyChangeListener(listener);
	}

	public void removePropertyChangeListener(PropertyChangeListener listener) {
		pcs.removePropertyChangeListener(listener);
	}

	// -- property name -------------------------------------------------------

	private String name;

	public String getName() {
		return name;
	}

	public void setName(String name) {
		Object oldValue = this.name;
		this.name = name;
		pcs.firePropertyChangeEvent("name", oldValue, name);
	}

}
+------------------------------------------------------------------------------+

  Spätestens wenn die Java Bean ein halbes Dutzend Eigenschaften besitzt, wird
  diese Schreibarbeit lästig. Um diesem Aufwand zu entgehen, kann man
  verschiedene Lösungen wählen:

  * Generierung. Entweder über MDA(?) oder Templates (Velocity). Nachteil:
    Der Generierungsschritt.

  * Aspekte? Nachteil: Noch nie ausprobiert. Wäre ein Versuch wert.

  * Groovy? Per Delegate. D.h. ein Groovy Composite definiert die
    PropertyChangeSupport Eigenschaften. Ein beliebiges Groovy Bean wird von
    dem Composite aufgenommen und delegiert alle unbekannten Methodenaufrufe
    an dem Composite an das Delegate. Dazu gibt es auch ein Beispiel im
    Groovy Testbereich: <<<DelegatePropertyChangeSupport.groovy>>> im Paket
    <<<de.gluehloch.util.bean>>>.
    Nachteil: Einbindung von Groovy. 

  * PropertyMediatorLazyDynaBean. Die Eigenschaften der Bean werden dynamisch
    zur Laufzeit angelegt (Ein fast ähnlicher Ansatz wie in Groovy).
    Nachteil: Das JGoodies Data-Binding kann nicht mit solchen Datentypen
    umgehen. JGoodies erwartet die entsprechende #getXxx() und #setXxx()
    Methode.

  * Per Proxy: Die Bean Methoden (getter und setter) sind als Schnittstelle
    hinterlegt. Das Proxy ist für das Feuern bei setter Aufrufen zuständig.

  * Einen interessanten Ansatz findet man im unteren Code-Beispiel.
    Funktioniert aber nur in der Groovy Welt.

  []
+------------------------------------------------------------------------------+
class PropertyChangeSupportComposite {
    private final delegate;
    private final pcs = new PropertyChangeSupport(this)

    PropertyChangeSupportComposite(def _delegate) {
        delegate = _delegate
    }

    void setProperty(String name, value) {
        if (hasLocalProperty(name)) {
            this.@"$name" = value
    	} else {
            def oldValue = getProperty(name)
            delegate.setProperty(name, value)
            pcs.firePropertyChange(name, oldValue, value)
        }
    }

    def getProperty(String name) {
        if (hasLocalProperty(name)) {
            return this.@"$name"
        } else {
            return delegate.getProperty(name)
        }
    }

    void addPropertyChangeListener(String key, PropertyChangeListener listener) {    
        pcs.addPropertyChangeListener(key, listener)
    }

    void addPropertyChangeListener(PropertyChangeListener listener) {
        pcs.addPropertyChangeListener(listener)
    }

    void removePropertyChangeListener(PropertyChangeListener listener) {
        pcs.removePropertyChangeListener(listener)
    }

    private hasLocalProperty(name) {
        metaClass.properties.collect{ it.name }.contains(name)
    }
    
}
+------------------------------------------------------------------------------+

Groovy Swing Programming

  Hier habe ich mich entschieden, die Groovy Bean nicht per Composite Pattern
  zu umhüllen, sondern per <<<ExpandoMetaClass>>> zu erweitern. Kern der
  Toolbox ist folgender Stück Groovy Code (Hier wird gezielt ein Objekt um
  PropertyChange Mechanismen erweitert):

+------------------------------------------------------------------------------+
static def preparePCLMechanics(objectToPimp) {
    def emc = new ExpandoMetaClass( objectToPimp.class, false )

    def support = new GroovyPropertyChangeSupport(wrappedObject: objectToPimp)
    emc.propertyChangeSupport << support

    emc.addPropertyChangeListener << { String key, PropertyChangeListener listener ->
        support.addPropertyChangeListener(key, listener)
    }
    emc.addPropertyChangeListener << { PropertyChangeListener listener ->
        support.addPropertyChangeListener(listener)
    }
    emc.removePropertyChangeListener << { PropertyChangeListener listener ->
        support.removePropertyChangeListener(listener)
    }

    emc.setProperty = { String key, value ->
        def metaProperty = objectToPimp.metaClass.getMetaProperty(key);
        def oldValue = delegate.getProperty(key);
        metaProperty.setProperty(delegate, value);
        support.firePropertyChangeEvent(key, oldValue, value)
    }
    emc.initialize()
    objectToPimp.metaClass = emc
    return objectToPimp
}
+------------------------------------------------------------------------------+

 Damit umgehe ich die Nachteile, die durch den Einsatz einens Composite
 entstehen können, z.B. den Verlust der Identität.

